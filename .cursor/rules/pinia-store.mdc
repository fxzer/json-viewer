---
description: 
globs: 
alwaysApply: true
---
# Pinia状态管理指南

JSON Viewer项目使用Pinia进行状态管理，本指南提供Pinia的使用规范和最佳实践。

## 状态管理结构

- 状态模块位于`src/store/module/`目录下
- 每个模块对应一个功能领域
- 主要模块：
  - `global.ts`: 全局设置和状态
  - `code.ts`: 代码相关状态
  - `layout.ts`: 布局相关状态

## 创建Store

每个状态模块应遵循以下结构：

```ts
// src/store/module/example.ts
import { defineStore } from 'pinia'
import type { ExampleState } from '@/types' // 导入类型定义

export const useExampleStore = defineStore('example', {
  // 状态，必须是函数返回一个新对象，以避免在模块之间共享状态
  state: (): ExampleState => ({ 
    items: [],
    isLoading: false,
    selectedId: null
  }),
  
  // getters类似于计算属性
  getters: {
    selectedItem: (state) => {
      if (!state.selectedId) return null
      return state.items.find(item => item.id === state.selectedId)
    },
    itemCount: (state) => state.items.length
  },
  
  // actions包含可以改变状态的方法
  actions: {
    // 同步操作
    selectItem(id: string) {
      this.selectedId = id
    },
    
    // 异步操作
    async fetchItems() {
      this.isLoading = true
      try {
        const response = await fetch('/api/items')
        const data = await response.json()
        this.items = data
      } catch (error) {
        console.error('Failed to fetch items:', error)
      } finally {
        this.isLoading = false
      }
    }
  },
  
  // 持久化配置（可选）
  persist: {
    // 持久化到localStorage
    enabled: true,
    strategies: [
      {
        key: 'example-store',
        storage: localStorage,
        paths: ['items', 'selectedId'] // 只持久化指定字段
      }
    ]
  }
})
```

## 类型定义

为store定义TypeScript类型，放在`src/types`目录下：

```ts
// src/types/store.ts
export interface ExampleState {
  items: Item[]
  isLoading: boolean
  selectedId: string | null
}

export interface Item {
  id: string
  name: string
  value: number
}
```

## 在组件中使用

在Vue组件中使用store：

```vue
<script setup lang="ts">
import { onMounted } from 'vue'
import { useExampleStore } from '@/store/module/example'
import { storeToRefs } from 'pinia'

// 初始化store
const exampleStore = useExampleStore()

// 解构，使用storeToRefs保持响应性
const { items, isLoading, selectedItem } = storeToRefs(exampleStore)

// 使用actions
function handleItemClick(id: string) {
  exampleStore.selectItem(id)
}

onMounted(() => {
  exampleStore.fetchItems()
})
</script>

<template>
  <div>
    <div v-if="isLoading">加载中...</div>
    <ul v-else>
      <li 
        v-for="item in items" 
        :key="item.id"
        :class="{ active: item.id === selectedItem?.id }"
        @click="handleItemClick(item.id)"
      >
        {{ item.name }}: {{ item.value }}
      </li>
    </ul>
  </div>
</template>
```

## 最佳实践

1. **模块化**：将不同功能的状态分离到不同的store模块
2. **类型定义**：为所有状态和传递的参数提供TypeScript类型
3. **保持store纯粹**：store应专注于状态管理，复杂业务逻辑应放在单独的服务中
4. **选择性持久化**：只持久化必要的状态数据，避免存储敏感信息或临时状态
5. **使用storeToRefs**：从store中提取响应式属性时使用`storeToRefs`保持响应性
6. **重置状态**：提供重置store状态的方法，特别是在用户会话结束时

```ts
// 在store中添加重置方法
actions: {
  reset() {
    // 使用$reset()重置为初始状态
    this.$reset()
  }
}
```
