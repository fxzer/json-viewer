---
description: 
globs: 
alwaysApply: false
---
# JSON可视化实现指南

JSON Viewer项目使用AntV G6图形可视化库实现JSON数据的可视化展示。本指南提供JSON数据可视化的实现方法和最佳实践。

## JSON解析与转换

JSON数据需要先解析然后转换为G6可视化库支持的格式：

```ts
// 解析JSON字符串
function parseJSON(jsonString: string) {
  try {
    return JSON.parse(jsonString)
  } catch (error) {
    console.error('JSON解析错误:', error)
    throw new Error('JSON格式错误，请检查')
  }
}

// 将JSON对象转换为G6数据格式
function convertJsonToG6Data(json: any) {
  const nodes: any[] = []
  const edges: any[] = []
  let nodeId = 0
  
  // 递归处理JSON对象
  function traverse(data: any, parentId: string | null = null, key: string | number = 'root') {
    const currentId = `node-${nodeId++}`
    const nodeType = getType(data)
    
    // 创建节点
    const node = {
      id: currentId,
      label: String(key),
      type: nodeType,
      style: getStyleByType(nodeType),
      // 存储原始数据
      origin: {
        key,
        type: nodeType,
        value: isPrimitive(data) ? data : undefined
      }
    }
    
    nodes.push(node)
    
    // 如果有父节点，创建边
    if (parentId !== null) {
      edges.push({
        source: parentId,
        target: currentId,
        style: {
          // 边的样式
        }
      })
    }
    
    // 处理子节点
    if (nodeType === 'object') {
      Object.keys(data).forEach(key => {
        traverse(data[key], currentId, key)
      })
    } else if (nodeType === 'array') {
      data.forEach((item: any, index: number) => {
        traverse(item, currentId, index)
      })
    }
  }
  
  // 获取数据类型
  function getType(data: any): string {
    if (data === null) return 'null'
    if (Array.isArray(data)) return 'array'
    return typeof data
  }
  
  // 判断是否是原始类型
  function isPrimitive(data: any): boolean {
    const type = getType(data)
    return type === 'string' || 
           type === 'number' || 
           type === 'boolean' || 
           type === 'null' || 
           type === 'undefined'
  }
  
  // 根据类型获取样式
  function getStyleByType(type: string) {
    const typeColors = {
      string: { fill: '#91d5ff', stroke: '#1890ff' },
      number: { fill: '#b7eb8f', stroke: '#52c41a' },
      boolean: { fill: '#ffe58f', stroke: '#faad14' },
      object: { fill: '#adc6ff', stroke: '#2f54eb' },
      array: { fill: '#d3adf7', stroke: '#722ed1' },
      null: { fill: '#ffd8bf', stroke: '#fa8c16' },
      undefined: { fill: '#f5f5f5', stroke: '#d9d9d9' }
    }
    
    return typeColors[type as keyof typeof typeColors] || 
           { fill: '#f5f5f5', stroke: '#d9d9d9' }
  }
  
  // 开始转换
  traverse(json)
  
  return { nodes, edges }
}
```

## 可视化组件实现

JsonCanvas.vue组件是实现JSON可视化的核心组件：

```vue
<template>
  <div class="json-canvas-container">
    <!-- 工具栏 -->
    <div class="toolbar">
      <button @click="zoomIn">放大</button>
      <button @click="zoomOut">缩小</button>
      <button @click="resetView">重置视图</button>
      <select v-model="layout" @change="updateLayout">
        <option value="dendrogram">树形布局</option>
        <option value="indented">缩进树布局</option>
        <option value="mindmap">思维导图布局</option>
      </select>
    </div>
    
    <!-- 图形容器 -->
    <div ref="container" class="graph-container"></div>
    
    <!-- 提示框 -->
    <div v-if="tooltip.visible" 
         class="tooltip" 
         :style="{ left: tooltip.x + 'px', top: tooltip.y + 'px' }">
      <div class="tooltip-title">{{ tooltip.title }}</div>
      <div class="tooltip-content">{{ tooltip.content }}</div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch, reactive } from 'vue'
import G6 from '@antv/g6'
import { useCodeStore } from '@/store/module/code'
import { convertJsonToG6Data, parseJSON } from '@/utils/json-transformer'

// 状态
const container = ref<HTMLElement | null>(null)
const layout = ref('dendrogram')
const graph = ref<any>(null)
const tooltip = reactive({
  visible: false,
  x: 0,
  y: 0,
  title: '',
  content: ''
})

// 获取代码store
const codeStore = useCodeStore()

// 初始化图实例
function initGraph() {
  if (!container.value) return
  
  // G6图配置
  const graphConfig = {
    container: container.value,
    width: container.value.clientWidth,
    height: container.value.clientHeight,
    modes: {
      default: [
        'drag-canvas',
        'zoom-canvas',
        {
          type: 'tooltip',
          formatText(model: any) {
            return `${model.label}: ${model.origin.value || ''}`;
          },
          offset: 10,
        },
        'click-select'
      ]
    },
    layout: {
      type: layout.value,
      direction: 'LR',
      nodeSep: 50,
      rankSep: 100
    },
    defaultNode: {
      type: 'rect',
      size: [100, 30],
      style: {
        radius: 4,
        cursor: 'pointer'
      },
      labelCfg: {
        style: {
          fill: '#000',
          fontSize: 12
        }
      }
    },
    defaultEdge: {
      type: 'cubic-horizontal',
      style: {
        stroke: '#91d5ff',
        endArrow: true
      }
    },
    // 节点状态样式
    nodeStateStyles: {
      selected: {
        stroke: '#f00',
        lineWidth: 2
      },
      hover: {
        stroke: '#1890ff',
        lineWidth: 2
      }
    }
  }
  
  // 创建图实例
  graph.value = new G6.Graph(graphConfig)
  
  // 监听事件
  registerEvents()
  
  // 渲染数据
  renderData()
  
  // 监听窗口大小变化
  window.addEventListener('resize', resizeGraph)
}

// 注册事件
function registerEvents() {
  if (!graph.value) return
  
  // 节点点击
  graph.value.on('node:click', (evt: any) => {
    const node = evt.item
    const model = node.getModel()
    console.log('点击节点:', model)
    
    // 处理节点点击逻辑
    // ...
  })
  
  // 节点悬停
  graph.value.on('node:mouseenter', (evt: any) => {
    const node = evt.item
    graph.value.setItemState(node, 'hover', true)
    
    // 显示提示框
    const model = node.getModel()
    const { x, y } = evt.canvas
    showTooltip(x, y, model.label, getTooltipContent(model))
  })
  
  graph.value.on('node:mouseleave', (evt: any) => {
    const node = evt.item
    graph.value.setItemState(node, 'hover', false)
    
    // 隐藏提示框
    hideTooltip()
  })
}

// 渲染数据
function renderData() {
  if (!graph.value) return
  
  try {
    // 从store获取JSON数据
    const jsonData = parseJSON(codeStore.code || '{}')
    
    // 转换为G6格式
    const g6Data = convertJsonToG6Data(jsonData)
    
    // 渲染图
    graph.value.data(g6Data)
    graph.value.render()
    
    // 自适应视图
    graph.value.fitView(20)
  } catch (error) {
    console.error('渲染数据错误:', error)
    // 显示错误信息
  }
}

// 更新布局
function updateLayout() {
  if (!graph.value) return
  
  graph.value.updateLayout({
    type: layout.value,
    direction: 'LR',
    nodeSep: 50,
    rankSep: 100
  })
}

// 缩放控制
function zoomIn() {
  if (!graph.value) return
  graph.value.zoom(1.1)
}

function zoomOut() {
  if (!graph.value) return
  graph.value.zoom(0.9)
}

function resetView() {
  if (!graph.value) return
  graph.value.fitView(20)
}

// 调整图大小
function resizeGraph() {
  if (!container.value || !graph.value) return
  
  graph.value.changeSize(
    container.value.clientWidth,
    container.value.clientHeight
  )
  graph.value.fitView(20)
}

// 提示框控制
function showTooltip(x: number, y: number, title: string, content: string) {
  tooltip.visible = true
  tooltip.x = x + 10
  tooltip.y = y + 10
  tooltip.title = title
  tooltip.content = content
}

function hideTooltip() {
  tooltip.visible = false
}

function getTooltipContent(model: any) {
  if (!model.origin) return ''
  
  if (model.origin.type === 'string' || 
      model.origin.type === 'number' || 
      model.origin.type === 'boolean') {
    return String(model.origin.value)
  }
  
  return model.origin.type
}

// 监听JSON数据变化
watch(() => codeStore.code, () => {
  renderData()
}, { deep: true })

// 初始化
onMounted(() => {
  initGraph()
})

// 销毁图实例
onBeforeUnmount(() => {
  if (graph.value) {
    graph.value.destroy()
  }
  window.removeEventListener('resize', resizeGraph)
})
</script>

<style scoped>
.json-canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.graph-container {
  width: 100%;
  height: 100%;
  background-color: #f0f2f5;
}

.toolbar {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 10;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 5px;
  border-radius: 4px;
  display: flex;
  gap: 5px;
}

.tooltip {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.75);
  color: #fff;
  padding: 8px 12px;
  border-radius: 4px;
  z-index: 100;
  max-width: 300px;
  word-break: break-all;
}

.tooltip-title {
  font-weight: bold;
  margin-bottom: 5px;
}
</style>
```

## 节点类型和样式

根据JSON数据类型定制不同的节点样式：

```ts
// 节点类型映射
const NODE_TYPES = {
  STRING: 'string',
  NUMBER: 'number',
  BOOLEAN: 'boolean',
  OBJECT: 'object',
  ARRAY: 'array',
  NULL: 'null'
}

// 类型样式映射
const TYPE_STYLES = {
  [NODE_TYPES.STRING]: {
    fill: '#91d5ff',
    stroke: '#1890ff',
    icon: 'text-icon'
  },
  [NODE_TYPES.NUMBER]: {
    fill: '#b7eb8f',
    stroke: '#52c41a',
    icon: 'number-icon'
  },
  [NODE_TYPES.BOOLEAN]: {
    fill: '#ffe58f',
    stroke: '#faad14',
    icon: 'boolean-icon'
  },
  [NODE_TYPES.OBJECT]: {
    fill: '#adc6ff',
    stroke: '#2f54eb',
    icon: 'object-icon'
  },
  [NODE_TYPES.ARRAY]: {
    fill: '#d3adf7',
    stroke: '#722ed1',
    icon: 'array-icon'
  },
  [NODE_TYPES.NULL]: {
    fill: '#ffd8bf',
    stroke: '#fa8c16',
    icon: 'null-icon'
  }
}

// 自定义节点配置
G6.registerNode('json-node', {
  draw(cfg, group) {
    // ... 节点绘制逻辑
  },
  update(cfg, node) {
    // ... 节点更新逻辑
  }
}, 'rect')
```

## 响应式更新

在JSON数据或布局选项变化时更新可视化：

```ts
// 监听JSON数据变化
watch(() => codeStore.code, (newCode) => {
  if (!newCode) return
  
  try {
    const jsonData = parseJSON(newCode)
    const g6Data = convertJsonToG6Data(jsonData)
    
    // 更新数据
    graph.value.changeData(g6Data)
    
    // 调整视图
    graph.value.fitView(20)
  } catch (error) {
    console.error('JSON数据更新错误:', error)
    // 显示错误提示
  }
}, { deep: true })

// 监听布局变化
watch(() => layoutOptions.value, (newOptions) => {
  if (!graph.value) return
  
  // 更新布局
  graph.value.updateLayout({
    type: newOptions.type,
    direction: newOptions.direction,
    nodeSep: newOptions.nodeSep,
    rankSep: newOptions.rankSep
  })
}, { deep: true })
```

## 交互增强

添加搜索、过滤等高级交互功能：

```ts
// 搜索节点
function searchNodes(keyword: string) {
  if (!graph.value || !keyword) return
  
  const nodes = graph.value.getNodes()
  let foundCount = 0
  
  // 重置所有节点样式
  nodes.forEach((node: any) => {
    graph.value.clearItemStates(node)
    
    // 恢复原始样式
    const model = node.getModel()
    const nodeType = model.origin.type
    graph.value.updateItem(node, {
      style: TYPE_STYLES[nodeType] || TYPE_STYLES.NULL
    })
  })
  
  // 高亮匹配节点
  nodes.forEach((node: any) => {
    const model = node.getModel()
    
    // 检查节点标签或值是否匹配
    const label = model.label || ''
    const value = model.origin?.value !== undefined ? 
                  String(model.origin.value) : ''
    
    if (label.includes(keyword) || value.includes(keyword)) {
      // 高亮显示
      graph.value.setItemState(node, 'highlight', true)
      foundCount++
    }
  })
  
  return foundCount
}

// 过滤节点
function filterByType(type: string) {
  if (!graph.value) return
  
  const nodes = graph.value.getNodes()
  
  nodes.forEach((node: any) => {
    const model = node.getModel()
    const visible = !type || model.origin.type === type
    
    // 设置节点可见性
    graph.value.updateItem(node, {
      visible
    })
    
    // 设置相关边的可见性
    const edges = node.getEdges()
    edges.forEach((edge: any) => {
      const edgeModel = edge.getModel()
      const sourceVisible = graph.value.findById(edgeModel.source).get('visible')
      const targetVisible = graph.value.findById(edgeModel.target).get('visible')
      
      // 只有当源节点和目标节点都可见时，边才可见
      graph.value.updateItem(edge, {
        visible: sourceVisible && targetVisible
      })
    })
  })
  
  // 调整视图
  if (type) {
    // 聚焦到可见节点
    const visibleNodes = nodes.filter((node: any) => node.get('visible'))
    if (visibleNodes.length > 0) {
      graph.value.focusItems(visibleNodes)
    }
  } else {
    // 重置视图
    graph.value.fitView(20)
  }
}
```
